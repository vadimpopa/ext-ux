/**
 * Created by vadim on 15/11/2018.
 */
Ext.define('Ext.ux.form.field.TreeCombobox', {
    extend: 'Ext.form.field.ComboBox',

    requires: [
        'Ext.util.Collection',
        'Ext.util.Filter',
        'Ext.ux.selection.ComboTreeModel',
        'Ext.ux.tree.BoundList'
    ],

    typeAheadDelay: 700,
    minChars: 3,
    autoSelect: false,
    autoSelectLast: false,
    queryMode: 'local',
    collapseOnSelect: false,

    store: {
        type: 'tree',
    },

    createPicker() {
        var me = this,
            picker,
            pickerCfg = Ext.apply({
                xclass: 'Ext.ux.tree.BoundList',
                id: me.id + '-picker',
                pickerField: me,
                selModel: me.pickerSelectionModel,
                store: me.getPickerStore(),
                viewConfig: {
                    pickerField: me
                },
                columns: [{
                    xtype: 'treecolumn',
                    text: null,
                    flex: 1,
                    dataIndex: this.displayField
                }]
            }, this.listConfig, this.defaultListConfig);

        picker = me.picker = Ext.widget(pickerCfg);

        // We limit the height of the picker to fit in the space above
        // or below this field unless the picker has its own ideas about that.
        if (!picker.initialConfig.maxHeight) {
            picker.on({
                beforeshow: me.onBeforePickerShow,
                scope: me
            });
        }
        picker.getSelectionModel().on({
            beforeselect: me.onBeforeSelect,
            beforedeselect: me.onBeforeDeselect,
            focuschange: me.onFocusChange,
            scope: me
        });

        picker.refresh = function () {
            this.getView().refresh();
        }.bind(picker);

        return picker;
    },

    onBindStore: function (store, initial) {
        var me = this,
            picker = me.picker,
            extraKeySpec,
            valueCollectionConfig;

        // We're being bound, not unbound...
        if (store) {
            // If store was created from a 2 dimensional array with generated field names 'field1' and 'field2'
            if (store.autoCreated) {
                me.queryMode = 'local';
                me.valueField = me.displayField = 'field1';
                if (!store.expanded) {
                    me.displayField = 'field2';
                }

                // displayTpl config will need regenerating with the autogenerated displayField name 'field1'
                if (me.getDisplayTpl().auto) {
                    me.setDisplayTpl(null);
                }
            }
            if (!Ext.isDefined(me.valueField)) {
                me.valueField = me.displayField;
            }

            // Add a byValue index to the store so that we can efficiently look up records by the value field
            // when setValue passes string value(s).
            // The two indices (Ext.util.CollectionKeys) are configured unique: false, so that if duplicate keys
            // are found, they are all returned by the get call.
            // This is so that findByText and findByValue are able to return the *FIRST* matching value. By default,
            // if unique is true, CollectionKey keeps the *last* matching value.
            extraKeySpec = {
                byValue: {
                    rootProperty: 'data',
                    unique: false
                }
            };
            extraKeySpec.byValue.property = me.valueField;
            store.setExtraKeys(extraKeySpec);

            if (me.displayField === me.valueField) {
                store.byText = store.byValue;
            } else {
                extraKeySpec.byText = {
                    rootProperty: 'data',
                    unique: false
                };
                extraKeySpec.byText.property = me.displayField;
                store.setExtraKeys(extraKeySpec);
            }

            // We hold a collection of the values which have been selected, keyed by this field's valueField.
            // This collection also functions as the selected items collection for the BoundList's selection model
            valueCollectionConfig = {
                rootProperty: 'data',
                extraKeys: {
                    byInternalId: {
                        property: 'internalId'
                    },
                    byValue: {
                        property: me.valueField,
                        rootProperty: 'data'
                    }
                },
                // Whenever this collection is changed by anyone, whether by this field adding to it,
                // or the BoundList operating, we must refresh our value.
                listeners: {
                    beginupdate: me.onValueCollectionBeginUpdate,
                    endupdate: me.onValueCollectionEndUpdate,
                    scope: me
                }
            };

            // This becomes our collection of selected records for the Field.
            me.valueCollection = new Ext.util.Collection(valueCollectionConfig);

            // This is the selection model we configure into the dropdown BoundList.
            // We use the selected Collection as our value collection and the basis
            // for rendering the tag list.
            me.pickerSelectionModel = new Ext.ux.selection.ComboTreeModel({
                mode: me.multiSelect ? 'SIMPLE' : 'SINGLE',
                // There are situations when a row is selected on mousedown but then the mouse is dragged to another row
                // and released.  In these situations, the event target for the click event won't be the row where the mouse
                // was released but the boundview.  The view will then determine that it should fire a container click, and
                // the DataViewModel will then deselect all prior selections. Setting `deselectOnContainerClick` here will
                // prevent the model from deselecting.
                ordered: true,
                deselectOnContainerClick: false,
                enableInitialSelection: false,
                pruneRemoved: false,
                selected: me.valueCollection,
                store: store,
                listeners: {
                    scope: me,
                    lastselectedchanged: me.updateBindSelection,
                    beforeselect(model, record) {
                        return record.isLeaf();
                    }
                }
            });

            if (!initial) {
                me.resetToDefault();
            }

            if (picker) {
                me.pickerSelectionModel.on({
                    scope: me,
                    beforeselect: me.onBeforeSelect,
                    beforedeselect: me.onBeforeDeselect
                });

                picker.getView().setSelectionModel(me.pickerSelectionModel);

                if (picker.getStore() !== store) {
                    picker.bindStore(store);
                }
            }
        }
    },

    onFocusChange: function (selModel, prevRecord, newRecord) {
        var picker = this.picker,
            inputEl = this.inputEl,
            el;

        if (newRecord) {
            el = picker.getView().getNodeByRecord(newRecord);
            if (!el.id) {
            }
            if (el) {
                // Need to make sure el has an id without leaving Ext.cache entry
                if (!el.id) {
                    el.id = Ext.id();
                }
                inputEl.dom.setAttribute('aria-activedescendant', el.id);
            } else {
                inputEl.dom.removeAttribute('aria-activedescendant');
            }
        }
    },

    /**
     * @private
     * Enables the key navs for the BoundList when it is expanded.
     */
    onExpand() {
        this.callParent();

        if (this.fieldKeyNav) {
            this.fieldKeyNav.enable();
        }
    },

    /**
     * @private
     * Disables the key navs for the BoundList when it is collapsed.
     */
    onCollapse() {
        this.callParent();

        if (this.fieldKeyNav) {
            this.fieldKeyNav.disable();
        }
    },

    onUnbindStore: function () {
        var me = this,
            picker = me.picker;
        // If we'd added a local filter, remove it.
        // Listeners are unbound, so we don't need the changingFilters flag
        if (me.queryFilter && !me.store.destroyed) {
            me.clearLocalFilter();
        }
        if (picker) {
            picker.setStore(null);
        }
        me.pickerSelectionModel.destroy();
    },

    doLocalQuery() {
        this.callParent(arguments);

        if (this.queryFilter) {
            this.expandFilteredNodes();
        }
    },

    expandFilteredNodes() {
        const store = this.store;

        Ext.suspendLayouts();

        ++store.bulkUpdate;

        store.each(function (record) {
            if (record.getTreeStore().data.indexOf(record) > -1 && !record.isLeaf() && !record.isExpanded()) {
                record.expand();
            }
        }, this, {
            collapsed: true,
            filtered: true
        });

        --store.bulkUpdate;

        Ext.resumeLayouts();
    }
});